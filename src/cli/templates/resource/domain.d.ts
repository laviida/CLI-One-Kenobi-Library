export declare const domain = "import { Create[entity]Dto } from '@controller/[filename]/dto/create-[filename].dto';\nimport { Update[entity]Dto } from '@controller/[filename]/dto/update-[filename].dto';\nimport { [entity] } from '@controller/[filename]/entities/[filename].entity';\nimport { EntityQuery } from '@core/database/dto/entity-query.dto';\nimport { ErrorDTO } from '@core/response/dto/error.dto';\nimport { HttpException, HttpStatus, Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { catchError, from, map, forkJoin } from 'rxjs';\nimport { EntityNotFoundError, Repository } from 'typeorm';\nimport { [entity]PageOptionsDto } from '@controller/[filename]/dto/[filename]-pagination-options.dto';\n\n@Injectable()\nexport class [entity]DomainService {\n  constructor(\n    @InjectRepository([entity])\n    private [filename]Repository: Repository<[entity]>,\n  ) {}\n\n  create(createChassisDto: Create[entity]Dto) {\n    return from(this.[filename]Repository.save(createChassisDto));\n  }\n\n  update(id: number, updateChassisDto: Update[entity]Dto) {\n    return from(this.[filename]Repository.save({ id, ...updateChassisDto }));\n  }\n\n  remove(id: number) {\n    return from(this.[filename]Repository.delete({ id }));\n  }\n\n  paginate(pageOptionsDto: [entity]PageOptionsDto) {\n    return forkJoin([\n      this.[filename]Repository.count(),\n      this.[filename]Repository.find({\n        order: {\n          [pageOptionsDto.orderBy]: pageOptionsDto.order,\n        },\n        where: pageOptionsDto.where,\n        skip: pageOptionsDto.skip,\n        take: pageOptionsDto.take,\n        relations: pageOptionsDto.relations as unknown as Array<string>,\n      }),\n    ]).pipe(\n      map(([totalItems, entities]) => {\n        return { totalItems, entities };\n      }),\n    );\n  }\n\n  find(options: EntityQuery<[entity]>) {\n    return from(\n      this.[filename]Repository.find({\n        where: options.where,\n        take: options.limit,\n      }),\n    ).pipe(\n      map(([filename]: Array<[entity]>) => {\n        if (options.orFail && [filename].length === 0)\n          throw new EntityNotFoundError(\n            [entity],\n            `${ [entity].name } entities not found. Filtered by: ${Object.keys(\n              options.where ?? [],\n            ).map((k) => `${k.toUpperCase()} (${k}: ${options.where[k]}), `)}`,\n          );\n        if ([filename].length === 0 && options.limit === 1) return null;\n        return options.limit === 1 ? [filename][0] : [filename];\n      }),\n      catchError((e: HttpException) => {\n        if (e instanceof EntityNotFoundError)\n          throw new HttpException(\n            { name: e.name, message: e.message } as ErrorDTO,\n            HttpStatus.NOT_FOUND,\n            { cause: e },\n          );\n        throw e;\n      }),\n    );\n  }\n}\n";
